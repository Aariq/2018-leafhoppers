---
title: "2017 Leafhopper GCMS analysis"
author: "Eric R. Scott"
date: "2019-08-01"
output: 
  html_notebook: 
    highlight: kate
    theme: yeti
    toc: yes
    toc_float: yes
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(scipen = 999) #turn off scientific notation
```

*Last compiled: `r Sys.Date()`*

```{r packages, include=FALSE}
library(tidyverse)
library(here)
library(readxl)
#for RDA:
library(vegan)
library(RVAideMemoire)
#for figures:
library(cowplot)
#for step and hinge models
library(chngpt)
```

# Purpose

What is the goal of this notebook?

# Load Data
Read in cleaned GCMS data (which includes leafhopper density already) and leafhopper damage data (from image analysis)

```{r data, echo=TRUE}
gc_wide <- read_rds(here("data", "cleaned", "2017_gcms_wide.rds"))
gc_tidy <- read_rds(here("data", "cleaned", "2017_gcms_tidy.rds"))
gc_wide.zeroes <- read_rds(here("data", "cleaned", "2017_gcms_zeroes.rds"))
```

```{r}
annotations <- read_excel(here("data", "cleaned", "Compound annotation updated.xlsx")) %>%
  rename(compound = Compound)
```


## Data Dictionary

`gc_tidy`: A tidy dataframe of all the chemistry and other data

- `sample`: Sample name
- `cultivar`: In this year, all plants were Qing Xin Da Mao, but I included this column for uniformity with the 2018 experiment.
- `density_start`: The density of leafhoppers applied at the start of the experiment in **insects/young leaf**
- `density_end`: Ending density in **insects/young leaf** 
- `mean_percent_damage`: Percentage of damaged pixels averaged across all leaves for that sample
- `twister_damage`: Percentage of damaged pixels for the leaf the volatiles were sampled from.
- `No.`: Compound number.  This comes from the Ion Analytics methods file.
- `Compound`: Compound name
- `RPA`: Relative peak area
- `rt`: retention time, in minutes
- `ri`: retention index
- `present`: logical. Was the compound detected in a particular sample?

`gc_wide`: A wide version with columns for each `Compound` with `RPA` as the value


# Data pre-treatment
Most data pre-treatment was done in the wrangling Rmd. I already determine that log transformation followed by scaling is probably a good idea to improve normality.  However, the data is still zero-inflated, so it might be better to just use a distance based approach instead, which I think is "nonparametric".  Maybe it doesnt' really matter though since the permuation test for the RDA is nonparametric anyway.

```{r}
#attribute stripper function
rm_attr <- function(x){
  attributes(x) <- NULL
  return(x)
  }

#columns that aren't compound RPAs
metavars <- c("sample", "cultivar", "density_start", "density_end", "mean_percent_damage", "twister_damage")
```
 

```{r}
gc_wide.logscale <- 
  gc_wide %>% 
  mutate_at(vars(-metavars), log) %>%
  mutate_at(vars(-metavars), scale) %>%
  #strip atrributes left by scale() that interfere with some other functions down the road
  mutate_at(vars(-metavars), rm_attr)

gc_wide.zeroes <- 
  gc_wide.zeroes %>% 
  mutate_at(vars(-metavars), scale) %>% 
  mutate_at(vars(-metavars), rm_attr)

#set up chemistry data for RDA
chemdata <- gc_wide.logscale %>% select(-metavars) %>% as.data.frame()
rownames(chemdata) <- gc_wide.logscale$sample
```

I may also want to log-transform the percent leaf damage data, but I can do that ad-hoc later.

```{r}
ggplot(gc_wide.logscale, aes(log(mean_percent_damage))) + geom_histogram(bins = 7)
```


# Descriptive statistics
## How many compounds total?

```{r}
length(unique(gc_tidy$Compound))
```

## How many compounds are found in all samples?

Only 4!

```{r}
gc_tidy %>% 
  group_by(Compound) %>% 
  summarize(nsample = sum(present)) %>% 
  filter(nsample > 18) %>% 
  rename(compound = Compound) %>%
  left_join(annotations)
```

# Analysis
## RDA for density
### Fit RDA model

Only analysis for the regular RDA is shown, because the distance-based RDA gave the same results and you can't get loadings from it.

```{r}
#scaled, transformed
rda_dens <-
  rda(chemdata ~ gc_wide.logscale$density_end)

# #try with un-transformed
# gc_wide.scale <- gc_wide.zeroes %>% mutate_at(vars(-metavars), scale)
# rda_dens2 <- rda(gc_wide.scale %>% select(-metavars) ~ gc_wide.scale$density_end)
# 
# ordiresids(rda_dens, kind = "qqmath",  residuals = "working")
# ordiresids(rda_dens2, kind = "qqmath", residuals = "working")
# #log transformation DEFINITELY helps improve normality
```

### How much total variance does the experimental design explain?

```{r}
synt_dens <- MVA.synt(rda_dens)
synt_dens[[1]]
```

yeesh, only 9.12% explained by ending density

### ANOVA

Test for significance that this amount of explained variance is higher than the null hypothesis of no effect of the experimental design:

```{r}
anova(rda_dens)
```

Significant effect of ending density on leaf volatiles


## RDA for damage
### Fit RDA

```{r}
rda_dam <- rda(chemdata ~ gc_wide.logscale$twister_damage)
```

### How much total variance does the experimental design explain?

```{r}
synt_dam <- MVA.synt(rda_dam)
synt_dam[[1]]
```
Twister leaf damage explains 8% of variation in loged scaled volatiles. 

### ANOVA
Test for significance that this amount of explained variance is higher than the null hypothesis of no effect of the experimental design:

```{r}
anova(rda_dam)
```

Marginally significant


## Biomarkers

I'm defining biomarkers as compounds that are significantly correlated to the RDA axis (correlation between axis scores and chemistry data) *or* are have a significant univariate relationship with the measure of herbivory

### leafhopper density biomarkers

#### Extract scores and loadings

```{r}
dens_scores <-
  scores(rda_dens, display = "sites", scaling = 0) %>% 
  as_tibble(rownames = "sample")

dens_loads <- scores(rda_dens, display = "species", scaling = 0) %>% 
  as_tibble(rownames = "compound")
```

#### Correlation between data and RDA axis

```{r}
dens_corr <-
  map_df(chemdata,
         ~cor.test(.x, dens_scores$RDA1) %>%
           broom::glance(),
         .id = "compound") %>% 
  select(compound, correlation = estimate, corr.p.value = p.value)
```

#### Univariate regressions

Log transformation improved normality of the whole dataset, so I should be consistent and use that here as well, and probably plot things on a log scale.  This kinda sucks because interpretation is more complicated, but I'm gonna do it for now.  Log transformation is better than log-link glm, because we *want* the variance to be transformed.

```{r}
myrc <- lm(Myrcene ~ density_end, data = gc_wide)
myrc.log <- lm(log(Myrcene) ~ density_end, data = gc_wide)
shapiro.test(myrc$residuals)
shapiro.test(myrc.log$residuals)
plot(myrc)
plot(myrc.log)

farn <- lm(`Farnesene<(E,E)-alpha->` ~ density_end, data = gc_wide)
farn.log <- lm(log(`Farnesene<(E,E)-alpha->`) ~ density_end, data = gc_wide)
farn.glm <- glm(`Farnesene<(E,E)-alpha->` ~ density_end, family = gaussian(link = "log"), data = gc_wide)
shapiro.test(farn$residuals)
shapiro.test(farn.log$residuals)
shapiro.test(farn.glm$residuals)
plot(farn)
plot(farn.log)
plot(farn.glm)
```

```{r}
biom_data <-
  gc_tidy %>% 
  add_column(rand = rnorm(nrow(gc_tidy), 0.00001, 0.00001)) %>% 
  mutate(log.RPA = log(RPA),
         density_end2 = density_end + abs(rand)) %>% 
  rename(compound = Compound)
  
dens_lm <- 
  biom_data %>% 
  group_by(compound) %>% 
  nest() %>% 
  mutate(lm = map(data, ~lm(log.RPA ~ density_end, data = .x))) %>% 
  mutate(lm.tidy = map(lm, ~broom::tidy(.))) %>% 
  unnest(lm.tidy, .preserve = lm) %>% 
  filter(term != "(Intercept)") %>% 
  select(-term) %>% 
  select(compound, lm, lm.slope = estimate, lm.p.value = p.value)

dens_lm
```


#### Step function

Write my own function to get p-value and changepoint from chngpt.test and coefs from chngptm.  Man, this package sucks.

```{r}
mychngpt <- function(formula.1, formula.2, ...){

  test <- chngpt.test(formula.1, formula.2, ...)
  m <- chngptm(formula.1, formula.2, ...)
  tidydf <- 
    coef(m) %>% 
    enframe(name = "term") %>% 
    spread(key = term, value = value) %>% 
    add_column(p.value = test$p.value,
               chngpt = test$chngpt)
  return(tidydf)
}
```


```{r}
dens_step <-
  biom_data %>% 
  nest() %>% 
  mutate(step = map(data,
                    ~mychngpt(log.RPA ~ 1, ~ density_end2,
                              data = .x,
                              type = "step",
                              family = "gaussian",
                              chngpts.cnt	= 100))) %>% 
  unnest(step) %>% 
  rename(step.p.value = p.value)
```


#### Join with loadings

I can save this one as a supplemental document later

```{r}
dens_load_tbl <- 
  full_join(dens_loads, dens_corr, by = "compound") %>%
  full_join(dens_lm, by = "compound") %>% 
  full_join(dens_step, by = "compound") %>% 
arrange(desc(abs(correlation)))
dens_load_tbl
```
```{r}
#TODO: save as supplemental
```

#### Filter

Filter by either significant correlation to RDA or significant univariate regression. Arrange by absolute value of correlation coefficient.

```{r}
dens_biomarkers <-
  dens_load_tbl %>% 
  # filter(corr.p.value <= 0.05 | lm.p.value <= 0.05) %>% 
  filter(corr.p.value <= 0.05) %>% 
  # Elizabeth suggested against doing this:
  mutate(lm.p.value = p.adjust(lm.p.value, "fdr"),
         step.p.value = p.adjust(step.p.value, "fdr")) %>%
  arrange(desc(abs(correlation))) %>% 
  select(-PC1) %>% 
  mutate(compound = fct_inorder(compound))
dens_biomarkers
```


### Biomarkers for damage

#### Extract scores and loadings
```{r}
dam_scores <- scores(rda_dam, display = "sites", scaling = 0) %>% as_tibble(rownames = "sample")
dam_loads <- scores(rda_dam, display = "species", scaling = 0) %>% as_tibble(rownames = "compound")
```

#### Correlation with RDA axis

```{r}
dam_corr <-
  map_df(chemdata,
         ~cor.test(.x, dam_scores$RDA1) %>% 
           broom::glance(),
         .id = "compound") %>% 
  select(compound, correlation = estimate, corr.p.value = p.value)
```

#### Univariate regressions

```{r}
dam_lm <- 
  biom_data %>% 
  group_by(compound) %>% 
  nest() %>% 
  mutate(lm = map(data, ~lm(log.RPA ~ twister_damage, data = .x))) %>% 
  mutate(lm.tidy = map(lm, ~broom::tidy(.))) %>% 
  unnest(lm.tidy, .preserve = lm) %>% 
  filter(term != "(Intercept)") %>% 
  select(-term) %>% 
  select(compound, lm, lm.slope = estimate, lm.p.value = p.value)

dam_lm
```

#### Step function

```{r}
dam_step <-
  biom_data %>% 
  nest() %>% 
  mutate(step = map(data,
                    ~mychngpt(log.RPA ~ 1, ~ twister_damage,
                              data = .x,
                              type = "step",
                              family = "gaussian",
                              chngpts.cnt	= 100))) %>% 
  unnest(step) %>% 
  rename(step.p.value = p.value)
```


#### Join with loadings

Later I can save this as supplemental document

```{r}
dam_load_tbl <-
  full_join(dam_loads, dam_corr, by = "compound") %>%
  full_join(dam_lm, by = "compound") %>% 
  full_join(dam_step, by = "compound")
```

```{r}
#TODO: save for supplemental
```

#### Filter

Filter by either significant correlation to RDA or significant univariate regression. Arrange by absolute value of correlation coefficient.

```{r}
dam_biomarkers <-
  dam_load_tbl %>% 
  # filter(corr.p.value <= 0.05 | lm.p.value <= 0.05) %>% 
  filter(corr.p.value <= 0.05) %>% 
  # Elizabeth suggested against doing this:
  mutate(lm.p.value = p.adjust(lm.p.value, "fdr"),
         step.p.value = p.adjust(step.p.value, "fdr")) %>%
  arrange(desc(abs(correlation))) %>% 
  select(-PC1)
dam_biomarkers
```

# Biomarker Table
Join data from both response variables and annotate with flavor percepts and CAS numbers.

It would be kind of nice if instead of slope I could report an effect size.

```{r}
dens_biomarkers <- left_join(dens_biomarkers, annotations)
dam_biomarkers <- left_join(dam_biomarkers, annotations)
biomarker_tab <-
  bind_rows(
  dens_biomarkers %>% add_column(response = "Density"),
  dam_biomarkers %>% add_column(response = "Damage")
) %>% 
  mutate_all(~na_if(.,"NA")) %>% #replace text NAs with actual NAs
  mutate(`Chemical Family` = snakecase::to_sentence_case(`Chemical Family`)) %>% 
  # only keep changepoing if changepoint test is significant
  mutate(chngpt = ifelse(step.p.value > 0.05, NA, chngpt)) %>% 
    mutate_if(is.numeric, round, 3) %>% 
  mutate(Compound = ifelse(is.na(`Pretty Name`), compound, `Pretty Name`)) %>% 
  select(Compound,
         CAS,
         "RDA axis loading" = RDA1,
         "Correlation to RDA axis" = correlation,
         "Correlation p-value" = corr.p.value,
         "Slope" = lm.slope,
         "Linear regression p-value" = lm.p.value,
         "Step" = chngpt,
         "Step p-value" = step.p.value,
         Aroma,
         `Chemical Family`,
         "Herbivory proxy" = response)
biomarker_tab
```

write to CSV for formatting in Numbers / Excel

```{r}
write_excel_csv(biomarker_tab, here("figs", "2017 biomarkers.csv"), na = "-")
```

# Plots

Rather than plotting all of the biomarkers, I'll choose some representatives that I want to write about in the discussion, I think.  Also, if the step/hinge functions are significant, I should plot both the lm line and the step/hinge

## Density Biomarkers

```{r}
# dens_data <- gc_tidy %>% filter(Compound %in% pull(dens_biomarkers, compound))

dens_data <-
  dens_biomarkers %>%
  #take top 9 biomarkers
  slice(1:9) %>% 
  unnest(data) %>% 
  mutate_at(vars("(Intercept)", "I(density_end2>chngpt)", "chngpt"), ~ifelse(step.p.value > 0.05, NA, .)) %>% 
  left_join(gc_tidy) %>% 
  mutate(`Pretty Name` = fct_reorder(`Pretty Name`, abs(correlation), .desc = TRUE))

dens_data2 <- 
  dens_data %>% filter(lm.p.value <= 0.05)

dens_plot <-
  ggplot(dens_data, aes(x = density_end, y = log.RPA)) +
  geom_point() +
  # add lm when significant
  geom_smooth(method = "lm", se = FALSE, data = dens_data2, linetype = 5, color = "grey50") +
  # add step when significant
  geom_segment(aes(x = 0,
                 xend = chngpt,
                 y = `(Intercept)`,
                 yend = `(Intercept)`), color = "grey50") +
  geom_segment(aes(x = chngpt,
                   xend = 1.142857,
                   y = `(Intercept)`+`I(density_end2>chngpt)`, 
                   yend = `(Intercept)`+`I(density_end2>chngpt)`), color = "grey50") +
  facet_wrap(~`Pretty Name`, scales = "free_y") +
  labs(y = "ln(Relative peak area)", x = "Leafhopper density (insects / young leaf)") +
  theme_bw()
dens_plot
```

```{r}
save_plot(here("figs", "density-biomarkers.png"), dens_plot,
          ncol = 3,
          nrow = 3, 
          base_height = 2,
          base_asp = 1.3)
```


## Damage biomarkers

```{r}
dam_data <-
  dam_biomarkers %>% 
  #take top 9 for plotting
  slice(1:9) %>% 
  unnest(data) %>% 
  mutate_at(vars("(Intercept)", "I(twister_damage>chngpt)", "chngpt"), ~ifelse(step.p.value > 0.05, NA, .)) %>% 
  left_join(gc_tidy) %>% 
  mutate(`Pretty Name` = fct_reorder(`Pretty Name`, abs(correlation), .desc = TRUE))

dam_data2 <- 
  dam_data %>% filter(lm.p.value <= 0.05)

dam_plot <-
  ggplot(dam_data, aes(x = twister_damage, y = log.RPA)) +
  geom_point() +
  # add lm when significant
  geom_smooth(method = "lm", se = FALSE, data = dam_data2, linetype = 5, color = "grey50") +
  # add step when significant
  geom_segment(aes(x = min(gc_tidy$twister_damage),
                 xend = chngpt,
                 y = `(Intercept)`,
                 yend = `(Intercept)`), color = "grey50") +
  geom_segment(aes(x = chngpt,
                   xend = max(gc_tidy$twister_damage),
                   y = `(Intercept)`+`I(twister_damage>chngpt)`, 
                   yend = `(Intercept)`+`I(twister_damage>chngpt)`), color = "grey50") +
  facet_wrap(~`Pretty Name`, scales = "free_y") +
  labs(y = "ln(Relative peak area)", x = "Percent damage to focal leaf") +
  theme_bw()
dam_plot
```

```{r}
save_plot(here("figs", "damage-biomarkers.png"), dam_plot,
          ncol = 3,
          nrow = 3,
          base_height = 2,
          base_asp = 1.3)
```
