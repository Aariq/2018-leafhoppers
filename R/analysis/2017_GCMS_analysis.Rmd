---
title: "2017 Leafhopper GCMS analysis"
author: "Eric R. Scott"
date: "2019-08-01"
output: 
  html_notebook: 
    highlight: kate
    theme: yeti
    toc: yes
    toc_float: yes
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(scipen = 999) #turn off scientific notation
```

*Last compiled: `r Sys.Date()`*

```{r packages, include=FALSE}
library(tidyverse)
library(here)
library(readxl)
#for RDA:
library(vegan)
library(RVAideMemoire)
#for figures:
library(cowplot)
#for step and hinge models
library(chngpt)
```

# Purpose

This is the main analysis of volatile data for the paper. Multivariate analysis with redundancy analysis (RDA).  I decided to go with RDA over PLSR because I like that it gives me the percentage of variation explained by the predictor variables (herbivory proxies) whereas PLSR just gives a R2 for the axis (how much variation in X and Y does the *axis* explain).  I then identify biomarkers as compounds with significant correlations to the first (only) RDA axis, and do some univariate tests on them to see if they best fit a null (intercept only), line, step function, or hinge and then plot the results and produce a table.

# Load Data
Read in cleaned GCMS data (which includes leafhopper density already) and leafhopper damage data (from image analysis)

```{r data, echo=TRUE}
gc_wide <- read_rds(here("data", "cleaned", "2017_gcms_wide.rds"))
gc_tidy <- read_rds(here("data", "cleaned", "2017_gcms_tidy.rds"))
# gc_wide.zeroes <- read_rds(here("data", "cleaned", "2017_gcms_zeroes.rds"))
```

```{r}
annotations <- 
  read_excel(here("data", "cleaned", "Compound annotation updated.xlsx"), na = "NA") %>%
  rename(compound = Compound)
```



## Data Dictionary

`gc_tidy`: A tidy dataframe of all the chemistry and other data

- `sample`: Sample name
- `cultivar`: In this year, all plants were Qing Xin Da Mao, but I included this column for uniformity with the 2018 experiment.
- `density_start`: The density of leafhoppers applied at the start of the experiment in **insects/young leaf**
- `density_end`: Ending density in **insects/young leaf** 
- `mean_percent_damage`: Percentage of damaged pixels averaged across all leaves for that sample
- `twister_damage`: Percentage of damaged pixels for the leaf the volatiles were sampled from.
- `No.`: Compound number.  This comes from the Ion Analytics methods file.
- `Compound`: Compound name
- `RPA`: Relative peak area
- `rt`: retention time, in minutes
- `ri`: retention index
- `present`: logical. Was the compound detected in a particular sample?

`gc_wide`: A wide version with columns for each `Compound` with `RPA` as the value


# Data pre-treatment
Most data pre-treatment was done in the wrangling Rmd. I already determine that log transformation followed by scaling is probably a good idea to improve normality.  However, the data is still zero-inflated, so it might be better to just use a distance based approach instead, which I think is "nonparametric".  Maybe it doesnt' really matter though since the permuation test for the RDA is nonparametric anyway.

```{r}
#attribute stripper function
rm_attr <- function(x){
  attributes(x) <- NULL
  return(x)
  }

#columns that aren't compound RPAs
metavars <- c("sample", "cultivar", "density_start", "density_end", "mean_percent_damage", "twister_damage")
```
 
**one outlier removed**

```{r}
gc_wide.logscale <- 
  gc_wide %>% 
  mutate_at(vars(-metavars), log) %>%
  mutate_at(vars(-metavars), scale) %>%
  #strip atrributes left by scale() that interfere with some other functions down the road
  mutate_at(vars(-metavars), rm_attr) %>% 
  #remove outlier found in wrangling script.
  filter(sample != "Q8")

gc_tidy <- gc_tidy %>% filter(sample != "Q8")
# gc_wide.zeroes <- 
#   gc_wide.zeroes %>% 
#   mutate_at(vars(-metavars), scale) %>% 
#   mutate_at(vars(-metavars), rm_attr)

#set up chemistry data for RDA
chemdata <-
  gc_wide.logscale %>% 
  select(-metavars) %>%
  as.data.frame()
rownames(chemdata) <- gc_wide.logscale$sample
```

# Descriptive statistics
## How many compounds total?

```{r}
length(unique(gc_tidy$Compound))
```

## How many compounds are found in all samples?

```{r}
gc_tidy %>% 
  group_by(Compound) %>% 
  summarize(nsample = sum(present)) %>% 
  filter(nsample > 17) %>% 
  rename(compound = Compound) %>%
  left_join(annotations)
```

# Analysis
## RDA for density
### Fit RDA model

Only analysis for the regular RDA is shown, because the distance-based RDA gave the same results and you can't get loadings from it.

```{r}
#scaled, transformed
rda_dens <-
  rda(chemdata ~ gc_wide.logscale$density_end)
```

### How much total variance does the experimental design explain?

```{r}
synt_dens <- MVA.synt(rda_dens)
synt_dens[[1]]
```
10.66%

### ANOVA

Test for significance that this amount of explained variance is higher than the null hypothesis of no effect of the experimental design:

```{r}
anova(rda_dens)
```

Significant effect of ending density on leaf volatiles


## RDA for mean percent damage
### Fit RDA

```{r}
rda_dam <- rda(chemdata ~ gc_wide.logscale$mean_percent_damage)
```

### How much total variance does the experimental design explain?

```{r}
synt_dam <- MVA.synt(rda_dam)
synt_dam[[1]]
```


### ANOVA
Test for significance that this amount of explained variance is higher than the null hypothesis of no effect of the experimental design:

```{r}
anova(rda_dam)
```

Not significant

## RDA for focal DCSE leaf damage
### Fit RDA

```{r}
rda_dam <- rda(chemdata ~ gc_wide.logscale$twister_damage)
```

### How much total variance does the experimental design explain?

```{r}
synt_dam <- MVA.synt(rda_dam)
synt_dam[[1]]
```


### ANOVA
Test for significance that this amount of explained variance is higher than the null hypothesis of no effect of the experimental design:

```{r}
anova(rda_dam)
```

Marginally significant? Not sure if should report biomarkers.


## Biomarkers

I'm defining biomarkers as compounds that are significantly correlated to the RDA axis (correlation between axis scores and chemistry data).

### leafhopper density biomarkers

#### Extract scores and loadings

```{r}
dens_scores <-
  scores(rda_dens, display = "sites", scaling = 0) %>% 
  as_tibble(rownames = "sample")

dens_loads <- scores(rda_dens, display = "species", scaling = 0) %>% 
  as_tibble(rownames = "compound")
```

#### Correlation between data and RDA axis

```{r}
dens_corr <-
  map_df(chemdata,
         ~cor.test(.x, dens_scores$RDA1) %>%
           broom::glance(),
         .id = "compound") %>% 
  select(compound, correlation = estimate, corr.p.value = p.value)
```


#### Join with loadings

I can pretty this one up and save it as supplemental later. Needs better names, CAS numbers

```{r}
dens_load_tbl <- 
  full_join(dens_loads, dens_corr, by = "compound") %>% 
  left_join(annotations) %>% 
  select(compound, `Pretty Name`, CAS, RDA1, correlation, corr.p.value, Aroma, `Chemical Family`, `RI Lab`, `RI Lit`, Source)
dens_load_tbl
```

#### Renaming unknowns
Hmm, this should maybe be done for both 2017 and 2018 at the same time.

```{r}
#TODO: do this in a diff document, use 2018 data too.
meanRIs <- gc_tidy %>% group_by(Compound) %>% summarize(meanRI = mean(ri, na.rm = TRUE))

dens_load_tbl1 <- left_join(dens_load_tbl, meanRIs, by = c("compound" = "Compound"))
unks <- dens_load_tbl1 %>% filter(is.na(CAS)) %>% arrange(meanRI) %>% add_column(unk_name = 1:15)
dens_load_tbl2 <-
  left_join(dens_load_tbl1, unks) %>% 
  mutate(`Pretty Name` = ifelse(is.na(unk_name), `Pretty Name`, unk_name)) %>% 
  mutate(`Pretty Name` = ifelse(is.na(`Pretty Name`), compound, `Pretty Name`)) %>% 
  select(-unk_name)
```

#### Filter

Filter by either significant correlation to RDA or significant univariate regression. Arrange by absolute value of correlation coefficient.

```{r}
dens_biomarkers <-
  dens_load_tbl2 %>% 
  filter(corr.p.value <= 0.05) %>% 
  arrange(desc(abs(correlation))) %>% 
  mutate(compound = fct_inorder(compound))
```

#### Univariate regressions

Log transformation improved normality of the whole dataset, so I should be consistent and use that here as well, and probably plot things on a log scale.  This kinda sucks because interpretation is more complicated, but I'm gonna do it for now.  Log transformation is better than log-link glm, because we *want* the variance to be transformed.

I'm going to fit a null (intercept only), linear, step, and hinge model to every compound and choose the winner with AIC.

```{r}
#Only need to do this on compounds in biomarkers list
biom_data <-
  gc_tidy %>% 
  mutate(log.RPA = log(RPA)) %>% 
  rename(compound = Compound) %>% 
  filter(compound %in% dens_biomarkers$compound)
```

```{r}
dens_univar <-
  biom_data %>% 
  group_by(compound) %>% 
  nest() %>% 
  #fit null, linear, step, and hing models
  mutate(null = map(data, ~lm(log.RPA ~ 1, data = .x)),
         line = map(data, ~lm(log.RPA ~ density_end, data = .x)),
         step = map(data, ~chngptm(log.RPA ~ 1, ~ density_end,
                                   family = "gaussian", type = "step", data = .x, var.type="bootstrap", ci.bootstrap.size=100)),
         hinge = map(data, ~chngptm(log.RPA ~ 1, ~ density_end, 
                                    family = "gaussian", type = "hinge", data = .x))) %>% 
  gather(-compound, -data, key = type, value = model) %>% 
  #extract winning glm from step and hing models
  mutate(fit = ifelse(type %in% c("step", "hinge"), map(model, ~.x$best.fit), model)) %>% 
  arrange(compound) %>% 
  mutate(AIC = map(fit, ~AIC(.x))) %>%
  unnest(AIC)
```
Choose the best model.

Null is the simplest (df = 0), folowed by line (df = 1), and step and hinge (df = 2).  I also want to ignore the step and hinge models if the confidence interval for the changepoint overlaps zero.  That indicates to me that a line or intercept only is a better fit.

```{r}
#note, this ONLY works when models are in order null, line, step, hinge
bestAIC <- function(AIC){
  if(any(AIC[1] >= AIC[2:4] + 2)){
    if(any(AIC[2] >= AIC[3:4] + 2)){
      return(min(AIC[3:4]))
    } else {
      return(AIC[2])
    }
  } else {
    return(AIC[1])
  }
}
```

Custom tidier for chngpt models.  Warning: this is not very reusable code.
```{r}
tidy.chngpt <- function(chngpt.mod) {
  df <- bind_cols(
    chngpt.mod$coefficients[1:2] %>% t() %>% as_tibble(),
    summary(chngpt.mod)$chngpt %>%  set_names(c("chngpt", "chngpt.lower.CI", "chngpt.upper.CI")) %>% t() %>% as_tibble()
  )
  return(df)
}
```

Get model info and coeficients and choose the best model by AIC, penalizing any hinge or step models that have threshold CIs that overlap zero.

```{r}
#TODO: also get rid of changepoints with CIs that overlap max(density_final)
dens_univar2 <- 
  dens_univar %>% 
  filter(type %in% c("step", "hinge")) %>% 
  mutate(coefs = map(model, tidy.chngpt)) %>% 
  unnest(coefs) %>% 
  select(-data, -model, -fit) %>% 
  left_join(dens_univar, .) %>% 
  #set AIC to very high if the threshold CI overlaps zero
  mutate(AIC = if_else(chngpt.lower.CI > 0 | is.na(chngpt.lower.CI), AIC, Inf)) %>%
  mutate(AIC = if_else(chngpt.upper.CI < max(gc_tidy$density_end) | is.na(chngpt.upper.CI), AIC, Inf)) %>% 
  group_by(compound) %>%
  # choose the best AIC as described above
  filter(AIC == bestAIC(AIC))

```

Create a column that is the slope when linear, the slope after the threshold when hinge, and the difference between intercepts when step.  The idea is to give the reader some idea of the direction and magnitude of the relationship without plotting all 30.

```{r}
dens_univar_out <-
  dens_univar2 %>% 
  mutate(estimate = case_when(type == "step"  ~ `I(density_end>chngpt)` - `(Intercept)`,
                              type == "hinge" ~ `(density_end-chngpt)+`,
                              type == "line"  ~ map_dbl(fit, ~coef(.x)[2]))) %>% 
  select(compound, type, estimate, threshold = chngpt)
```


#### Merge with loadings and correlations

Biomarker table should have: 

- Compound (pretty name)
- CAS
- RDA loading
- Correlation
- Correlation p-value (??)
- Response type (null, linear, hinge, step)
- Response estimate (linear = slope, hinge = slope after threshold, step = intercept2 - intercept1)
- Change point
- Chemical family (???)
- Aroma

```{r}
table1 <-
  left_join(dens_biomarkers, dens_univar_out) %>% 
  mutate_if(is.numeric, round, 3) %>% 
  #format correlations with astrixes instead of showing p-values
  mutate(correlation = case_when(
    corr.p.value <= 0.001 ~ paste0(correlation, "***"),
    corr.p.value <= 0.01  ~ paste0(correlation, "**"),
    corr.p.value <=0.05   ~ paste0(correlation, "*"),
    TRUE                  ~ as.character(correlation)
  )) %>% 
  select(Compound = `Pretty Name`,
         CAS,
         "RDA Loading" = RDA1,
         Correlation = correlation,
         "Response type" = type,
         "Response estimate" = estimate,
         "Change point" = threshold,
         `Chemical Family`,
          Aroma)

write_excel_csv(table1, here("figs", "2017 biomarkers_updated.csv"), na = "-")
```

### Biomarkers for damage

#### Extract scores and loadings

```{r}
dam_scores <- scores(rda_dam, display = "sites", scaling = 0) %>% as_tibble(rownames = "sample")
dam_loads <- scores(rda_dam, display = "species", scaling = 0) %>% as_tibble(rownames = "compound")
```

#### Correlation with RDA axis

```{r}
dam_corr <-
  map_df(chemdata,
         ~cor.test(.x, dam_scores$RDA1) %>% 
           broom::glance(),
         .id = "compound") %>% 
  select(compound, correlation = estimate, corr.p.value = p.value)
```

#### Univariate regressions

```{r}
dam_lm <- 
  biom_data %>% 
  group_by(compound) %>% 
  nest() %>% 
  mutate(lm = map(data, ~lm(log.RPA ~ twister_damage, data = .x))) %>% 
  mutate(lm.tidy = map(lm, ~broom::tidy(.))) %>% 
  unnest(lm.tidy, .preserve = lm) %>% 
  filter(term != "(Intercept)") %>% 
  select(-term) %>% 
  select(compound, lm, lm.slope = estimate, lm.p.value = p.value)

dam_lm
```

#### Step function

```{r}
dam_step <-
  biom_data %>% 
  group_by(compound) %>% 
  nest() %>% 
  mutate(step = map(data,
                    ~mychngpt(log.RPA ~ 1, ~ twister_damage,
                              data = .x,
                              type = "step",
                              family = "gaussian",
                              chngpts.cnt	= 100))) %>% 
  unnest(step) %>% 
  rename(step.p.value = p.value)
```


#### Join with loadings

Later I can save this as supplemental document

```{r}
dam_load_tbl <-
  full_join(dam_loads, dam_corr, by = "compound") %>%
  full_join(dam_lm, by = "compound") %>% 
  full_join(dam_step, by = "compound")
```

```{r}
#TODO: save for supplemental
```

#### Filter

Filter by either significant correlation to RDA or significant univariate regression. Arrange by absolute value of correlation coefficient.

```{r}
dam_biomarkers <-
  dam_load_tbl %>% 
  # filter(corr.p.value <= 0.05 | lm.p.value <= 0.05) %>% 
  filter(corr.p.value <= 0.05) %>% 
  # Elizabeth suggested against doing this:
  # mutate(lm.p.value = p.adjust(lm.p.value, "fdr"),
  #        step.p.value = p.adjust(step.p.value, "fdr")) %>%
  arrange(desc(abs(correlation))) %>% 
  select(-PC1)
dam_biomarkers
```

# Biomarker Table
Join data from both response variables and annotate with flavor percepts and CAS numbers.

It would be kind of nice if instead of slope I could report an effect size.

```{r}
#Join with annotations to get CAS numbers and better names
dens_biomarkers <- left_join(dens_biomarkers, annotations)
dam_biomarkers <- left_join(dam_biomarkers, annotations)
```

```{r}
#Combine density and damage biomarkers
biomarker_tab <-
  bind_rows(
  dens_biomarkers %>% add_column(response = "Density"),
  dam_biomarkers %>% add_column(response = "Damage")
) 
```

Formatting:
```{r}
biomarker_tab1 <-
  biomarker_tab %>% 
  mutate_all(~na_if(.,"NA")) %>% #replace text NAs with actual NAs
  # get pretty names, unless it's an unkown
  mutate(Compound = ifelse(is.na(`Pretty Name`), compound, `Pretty Name`)) %>%
  # formate chemical family
  mutate(`Chemical Family` = snakecase::to_sentence_case(`Chemical Family`)) %>% 
  # Add significance stars to all coefficients
  mutate_if(is.numeric, round, 3) %>% 
  mutate(lm.slope = case_when(
    lm.p.value <= 0.001 ~ paste0(lm.slope, "***"),
    lm.p.value <= 0.01  ~ paste0(lm.slope, "**"),
    lm.p.value <=0.05   ~ paste0(lm.slope, "*"),
    TRUE                ~ as.character(lm.slope)
  )) %>% 
  mutate(correlation = case_when(
    corr.p.value <= 0.001 ~ paste0(correlation, "***"),
    corr.p.value <= 0.01  ~ paste0(correlation, "**"),
    corr.p.value <=0.05   ~ paste0(correlation, "*"),
    TRUE                  ~ as.character(correlation)
  )) %>% 
  #might also need to include upper bounds above max damage/max density
  mutate(chngpt = case_when(
    step.p.value <= 0.001 & chngpt.lowerCI > 0  ~ paste0(chngpt, "***"),
    step.p.value <= 0.01 & chngpt.lowerCI > 0   ~ paste0(chngpt, "**"),
    step.p.value <= 0.05 & chngpt.lowerCI > 0   ~ paste0(chngpt, "*"),
    step.p.value <= 0.05 & chngpt.lowerCI <= 0 ~ paste0(chngpt, "a"), 
    TRUE                                        ~ as.character(chngpt)
  ))

gc_tidy %>% filter(sample == "Q1") %>% select(No., Compound) %>% filter(Compound %in% biomarker_tab$compound) %>% write_csv(here("comounds to check censoring.csv"))
```
Select columns
```{r}
biomarker_tab2 <-
  biomarker_tab1 %>% 
  select("Herbivory proxy" = response,
         Compound,
         CAS,
         "RDA axis loading" = RDA1,
         "Correlation to RDA axis" = correlation,
         # "Correlation p-value" = corr.p.value,
         "Linear regression slope" = lm.slope,
         # "Linear regression p-value" = lm.p.value,
         "Change point" = chngpt,
         # "Step p-value" = step.p.value,
         Aroma,
         `Chemical Family`)
biomarker_tab2
```

write to CSV for formatting in Numbers / Excel

```{r}
write_excel_csv(biomarker_tab2, here("figs", "2017 biomarkers.csv"))
```

# Plots

Rather than plotting all of the biomarkers, I'll choose some representatives that I want to write about in the discussion, I think.  Also, if the step/hinge functions are significant, I should plot both the lm line and the step/hinge

## Density Biomarkers


```{r}
dens_plotdata <- 
  full_join(dens_biomarkers, dens_univar2, by = "compound") %>% 
  # full_join(annotations, by = "compound") %>% 
  dplyr::slice(1:9) %>% 
  left_join(biom_data, by = "compound") %>% 
  mutate(`Pretty Name` = fct_reorder(`Pretty Name`, abs(correlation), mean, .desc = TRUE))

#just linear models
dens_justlm <- dens_plotdata %>% filter(type == "line")
```

```{r}
dens_plot <- 
  ggplot(dens_plotdata, aes(x = density_end, y = log.RPA)) +
  geom_point(alpha = 0.5) +
  geom_segment(aes(x = 0,
                 xend = chngpt,
                 y = `(Intercept)`,
                 yend = `(Intercept)`), color = "black") +
  #step
  geom_segment(aes(x = chngpt,
                   xend = 1,
                   y = `(Intercept)`+`I(density_end>chngpt)`, 
                   yend = `(Intercept)`+`I(density_end>chngpt)`), color = "black") +
  #hinge
  geom_segment(aes(x = chngpt,
                   xend = 1,
                   y = `(Intercept)`,
                   yend = `(Intercept)` * `(density_end-chngpt)+`)) +
  #line
  geom_smooth(method = "lm", se = FALSE, color = "black", data = dens_justlm, size = 0.5) +
  facet_wrap(~`Pretty Name`, scales = "free_y") +
  labs(x = "Leafhopper density (insects / leaf)",
       y = "ln(relative peak area)") +
  theme_bw()
dens_plot
```

OLD:
```{r}
# dens_data <- gc_tidy %>% filter(Compound %in% pull(dens_biomarkers, compound))

dens_data <-
  dens_biomarkers %>%
  #take top 9 biomarkers
  slice(1:9) %>% 
  unnest(data) %>% 
  mutate_at(vars("(Intercept)", "I(density_end>chngpt)", "chngpt"),
            ~ifelse(step.p.value > 0.05 | chngpt.lowerCI <=0, NA, .)) %>% 
  left_join(gc_tidy) %>% 
  mutate(`Pretty Name` = fct_reorder(`Pretty Name`, abs(correlation), .desc = TRUE))

dens_data2 <- 
  dens_data %>% filter(lm.p.value <= 0.05 & is.na(chngpt))

dens_plot <-
  ggplot(dens_data, aes(x = density_end, y = log.RPA)) +
  geom_point(alpha = 0.5) +
  # add lm when significant
  geom_smooth(method = "lm", se = FALSE, data = dens_data2, linetype = 5, size = 0.5, color = "black") +
  # add step when significant
  geom_segment(aes(x = 0,
                 xend = chngpt,
                 y = `(Intercept)`,
                 yend = `(Intercept)`), color = "black") +
  geom_segment(aes(x = chngpt,
                   xend = 1.142857,
                   y = `(Intercept)`+`I(density_end>chngpt)`, 
                   yend = `(Intercept)`+`I(density_end>chngpt)`), color = "black") +
  facet_wrap(~`Pretty Name`, scales = "free_y") +
  labs(y = "ln(Relative peak area)", x = "Leafhopper density (insects / young leaf)") +
  theme_bw() #+ 
  # geom_hline(aes(yintercept = log(1000/306997)), color = "red")

dens_plot
```

```{r}
save_plot(here("figs", "density-biomarkers.png"), dens_plot,
          ncol = 3,
          nrow = 3, 
          base_height = 2,
          base_asp = 1.3)
```


## Damage biomarkers

```{r}
dam_data <-
  dam_biomarkers %>% 
  #take top 9 for plotting
  slice(1:9) %>% 
  unnest(data) %>% 
  mutate_at(vars("(Intercept)", "I(twister_damage>chngpt)", "chngpt"),
            ~ifelse(step.p.value > 0.05 | chngpt.lowerCI <= 0, as.numeric(NA), .)) %>% 
  left_join(gc_tidy) %>% 
  mutate(`Pretty Name` = fct_reorder(`Pretty Name`, abs(correlation), .desc = TRUE))

dam_data2 <- 
  dam_data %>% filter(lm.p.value <= 0.05 & is.na(chngpt))

dam_plot <-
  ggplot(dam_data, aes(x = twister_damage, y = log.RPA)) +
  geom_point(alpha = 0.5) +
  # add lm when significant
  geom_smooth(method = "lm", se = FALSE, data = dam_data2, linetype = 5, size = 0.5, color = "black") +
  # add step when significant
  geom_segment(aes(x = min(gc_tidy$twister_damage),
                 xend = chngpt,
                 y = `(Intercept)`,
                 yend = `(Intercept)`), color = "black") +
  geom_segment(aes(x = chngpt,
                   xend = max(gc_tidy$twister_damage),
                   y = `(Intercept)`+`I(twister_damage>chngpt)`, 
                   yend = `(Intercept)`+`I(twister_damage>chngpt)`), color = "black") +
  facet_wrap(~`Pretty Name`, scales = "free_y") +
  labs(y = "ln(Relative peak area)", x = "Percent damage to focal leaf") +
  theme_bw()
dam_plot
```

```{r}
save_plot(here("figs", "damage-biomarkers.png"), dam_plot,
          ncol = 3,
          nrow = 3,
          base_height = 2,
          base_asp = 1.3)
```
